## Расстояние Левенштейна

### Задача

Есть массив из 10 млн уникальных строк. Программа получает новую строку, необходимо найти все строки из массива,
удовлетворяющие критерий: расстояние Левенштейна к новой строке менее 3 операций.

### Нахождение расстояния между двумя строками

Для решения задачи реализуем на php алгоритм Вагнера-Фишера

```php 
/**
 * Нахождение расстояния Левенштейна между двумя строками
 *
 * @param $str1
 * @param $str2
 * @return int - искомое расстояние
 */
function levenshtein_distance($str1, $str2): int
{
    $n = mb_strlen($str1);
    $m = mb_strlen($str2);
    if ($n > $m) {
        list($str1, $str2) = [$str2, $str1];
        list($n, $m) = [$m, $n];
    }
    $currentRow = range(0, $n);
    for ($i = 1; $i <= $m; $i++) {
        $previousRow = $currentRow;
        $currentRow = [$i];
        for ($j = 1; $j <= $n; $j++) {
            $add = $previousRow[$j] + 1;
            $delete = $currentRow[$j - 1] + 1;
            $change = $previousRow[$j - 1] + (int)(mb_substr($str1, $j - 1, 1) !== mb_substr($str2, $i - 1, 1));
            $currentRow[$j] = min($add, $delete, $change);
        }
    }
    return $currentRow[$n];
}
```

Здесь, в целях оптимизации, мы храним только две последние строки, которые используются при вычислениях, вместо полной
матрицы.

Также, если строки разной длины, мы позиционируем матрицу вертикально. Строки получаются короче и мы дополнительно
экономим память.

Функции с префиксом `mb_` используются для корректной работы с кириллицей. Пакет `php-mbstring` должен присутствовать.

### Поиск похожих строк в большом массиве

Для решения этой задачи используем реализованный выше алгоритм в новой функции.

```php 
/**
 * Поиск похожих строк в массиве
 *
 * @param array $haystack
 * @param string $needle
 * @param int $less - ограничение по расстоянию между строками, строки на расстоянии $less от данной не включаются в итоговую выборку
 * @return array
 */
function levenshtein_distance_less_filter(array $haystack, string $needle, int $less = 3): array
{
    $result = [];
    if ($less < 1) return $result;
    $len_needle = mb_strlen($needle);
    foreach ($haystack as $item) {
        $n = $len_needle;
        $m = mb_strlen($item);
        $diff = abs($n - $m);
        if ($diff >= $less) continue;

        $str1 = $needle;
        $str2 = $item;

        if ($n > $m) {
            list($str1, $str2) = [$str2, $str1];
            list($n, $m) = [$m, $n];
        }

        $currentRow = range(0, $n);

        for ($i = 1; $i <= $m; $i++) {
            $previousRow = $currentRow;
            $currentRow = [$i];

            $j_max = min($n, $i + 1);
            $j_min = max(1, $i - $less + 1);
            for ($j = $j_min; $j <= $j_max; $j++) {
                $add = ($previousRow[$j] ?? INF) + 1;
                $delete = ($currentRow[$j - 1] ?? INF) + 1;
                $change = $previousRow[$j - 1] + (int)(mb_substr($str1, $j - 1, 1) !== mb_substr($str2, $i - 1, 1));
                $currentRow[$j] = min($add, $delete, $change);
                if ($i == $j && $currentRow[$j] >= $less) continue 3;
            }
        }

        if ($currentRow[$n] < $less)
            $result[] = $item;
    }

    return $result;
}
```

Поскольку применять к каждому элементу первую функцию невыгодно, мы должны отсеять заведомо неподходящие элементы и
оптимизировать алгоритм.

При переборе элементов сразу сравниваем длины строк, если разница >= $less (в нашем случае 3), то пропускаем строку и
переходим к следующей.

Заметим, что рост значений на диагонали матрицы медленнее, поэтому, если на диагонали попадется значение равное $less,
значит считать результат по этой паре строк уже нет смысла и мы переходим к следующей.

В отличие от первой функции, здесь мы дополнительно экономим память, заполняя матрицу только вблизи диагонали. Поскольку
искомое значение лежит на диагонали или находится под ней (матрица вертикальная), то над диагональю можем захватить
полосу шириной в 1 для корректного подсчета элементов самой диагонали.

---

Дополнительно ускорить работу программы можно с помощью кеширования результатов работы. Можно хранить в кеше весь
результат работы функции `levenshtein_distance_less_filter` по конкретной строке. Также можно хранить посчитанное
однажды расстояние между двумя строками.
